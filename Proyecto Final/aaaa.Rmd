---
title: "Análisis de datos proyecto Final de experimentos I"
author: "Daniel Sibaja Salazar"
date: "2024-05-16"
output: pdf_document
---

# Preparación

Se cargan los datos. Es necessario pasar las observaciones a tipo factor.

```{r}
library(readxl)
base1=read_xlsx("final_registro_cloud.xlsx",col_names = FALSE)
names(base1)=c("Tiempo","BL","Nube","Denied","Right","Solicitudes","ID","Bloque")
base1$BL=as.factor(base1$BL)
base1$Solicitudes=as.factor(base1$Solicitudes)
base1$Nube=as.factor(base1$Nube)




base2=read_xlsx("final_registro_local.xlsx",col_names = FALSE)
names(base2)=c("Tiempo","BL","Nube","Denied","Right","Solicitudes","ID","Bloque")
base2$BL=as.factor(base2$BL)
base2$Solicitudes=as.factor(base2$Solicitudes)
base2$Nube=as.factor(base2$Nube)
```

Podemos unir las bases para que sea solo una tabla grande y ver los tratamientos

```{r}
base=rbind(base1,base2)
table(base$BL,base$Nube,base$Solicitudes)

```

Vemos que hay un desbalance con los tratamientos, según el experto se pueden eliminar parcelas, se eliminan las que causan el desbalance

```{r}
quitar1=which(base1$Bloque=="N109")
base1=base1[-quitar1,]

quitar2=which(base1$Bloque=="N1009")
base1=base1[-quitar2,]

quitar3=which(base1$Bloque=="N5009")
base1=base1[-quitar3,]

quitar4=which(base1$Bloque=="N5006")
base1=base1[-quitar4,]

quitar5=which(base2$Bloque=="L5006")
base2=base2[-quitar5,]

quitar6=which(base1$Bloque=="N5008")
base1=base1[-quitar6,]

quitar7=which(base2$Bloque=="L5008")
base2=base2[-quitar7,]

quitar8=which(base1$Bloque=="N5004")
base1=base1[-quitar8,]

quitar9=which(base2$Bloque=="L5004")
base2=base2[-quitar9,]

quitar10=which(base1$Bloque=="N1007")
base1=base1[-quitar10,]

quitar11=which(base2$Bloque=="L1007")
base2=base2[-quitar11,]

base=rbind(base1,base2)
table(base$BL,base$Nube,base$Solicitudes)
```

Se soluciona el desbalance, ahora los bloques deben de coincidir.

# Descriptivos

```{r}
options(scipen = 999)
tapply(base$Tiempo,list(base$BL,base$Nube,base$Solicitudes),mean)
tapply(base$Tiempo,list(base$BL,base$Nube,base$Solicitudes),var)
```

Observamos que son valores que están cercanos a 0, esto se debe a que la variable respuesta está dada en segundos y pero los valores de tiempo son mucho más pequeños que un segundo.

```{r}
base$TiempoT=base$Tiempo*100
tapply(base$TiempoT,list(base$BL,base$Nube,base$Solicitudes),mean)
tapply(base$TiempoT,list(base$BL,base$Nube,base$Solicitudes),var)
```

Parece que en centisegundos todo tiene un poco más de coherencia.

**ESTO SE DEBE DE PONER EN UNA TABLA**

# El modelo

El modelo es un modelo mixto de parcelas divididas, el cual debe de cumplir los supuestos de normalidad y de homocedasticidad.

Es el siguiente:

$$
\mu_{ijk}=\mu+\alpha_i+\beta_j+\delta_k+(\alpha \beta)_{ij}+(\alpha\delta)_{ik}+(\beta \delta)_{jk}+(\alpha \beta \delta)_{ijk}+\nu_l
$$ 


Donde:

-   $\mu$ es la media general
-   $\alpha_i$ es el efecto del nivel i del Factor BlackList
-   $\beta_j$ es el efecto del nivel j del Factor Nube
-   $\delta_k$ es el efecto del nivel k del Factor Solicitudes
-   $(\alpha \beta)_{ij}$ es el efecto de la interacción entre BlackList y Nube
-   $(\alpha \delta)_{ik}$ es el efecto de la interacción entre BlackList y Solicitudes
-   $(\beta \delta)_{jk}$ es el efecto de la interacción entre Nube y Solicitudes
-   $\nu_l$ Es el efecto de la parcela. 


```{r}
library(lme4)
library(lmtest)

class(modp1)
modp1=lmer(log(TiempoT)~BL*Nube*Solicitudes+(1|Bloque),data = base)


library(nlme)

modp2=lme(TiempoT~BL*Nube*Solicitudes,random = ~ 1 | Bloque,data=base)
b=summary(modp1)
modp3=glmer(TiempoT~BL*Nube*Solicitudes+(1|Bloque),family = Gamma(link = "log"),data = base)
modp4=glm(TiempoT~BL*Nube*Solicitudes,family = Gamma(link = "log"),data = base)
a=summary(modp3)
a$residuals

anova(modp3,modp4,test="LRT")
```

## Supuestos del modelo 

```{r}
car::qqPlot(a$residuals)
hist(base$TiempoT)
hat=hat(base$TiempoT)
plot(hat);abline(h=2*mean(hat))
shapiro.test(modp3)
ks.test(a$residuals,"pnorm")

boxplot(base$TiempoT)

library(forcast)
library(MASS)
b1<-boxcox(modp1)
summary(modp1)$res


plot(a$residuals,a$fits)
plot(b$residuals,b$fits)
```

```{r}
library(dplyr)
residuos=as.data.frame(a$residuals)
library(ggplot2)
ggplot(data=residuos,aes(x=a$residuals))+stat_qq()
qplot(sample = residuos$`a$residuals`, data = residuos)
```


```{r}
library(qqplotr)
res.stnd = scale(residuos$`a$residuals`) # <- Residuos estandarizados. 

p1=ggplot(data = residuos, mapping = aes(sample = res.stnd )) + stat_qq_point() +                          stat_qq_line(color="blue") + stat_qq_band(fill=NA, color="blue") +
      ylab("Residuos Estandarizados") + xlab("Norm Quantiles") + ggtitle("Normal QQ Plot")  +             labs(caption = "Grafico 1")+ theme_classic()+ ylim(-100, 100); p1
```




















Protocolo UDP Protocolo TCP


