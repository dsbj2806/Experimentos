---
title: "Diseño de Bloques"
author: "Daniel Sibaja Salazar"
date: "2024-05-21"
output:
  html_document:
    toc: yes
    toc_float: yes
    css: "tema1.css"
---

# Concepto 

Hay veces en el que las unidades experimentales no son muy parecidas entre sí, o entre ellas pueden haber diferencias que afecten los resultados del experimento. En este caso el diseño al azar no es óptimo 

- Aunque también es posible generar bloques de unidades similares  para mejorar la sensibilidad del experimento. 

Este agrupamiento de unidades no homogeneas en grupos homogeneos significa un beneficio en el sentido de que se reduce el error e incrementa el rango de validez para hacer inferencia. 

También es posible que los bloques se construyan de forma natural. 

Se aplican tantas unidaddes dentro del bloque como tratamientos se estén analizando, estos tratamientos se asignan aleatoriamente dentro del bloque 

En este sentido los bloques son unidades estadísticas compuestas que se extraen de una población de bloques. Dentro del bloque están las unidades estadísticas a analizar. 

- Esto quiere decir que tenemos una muestra de bloques proveniente de una población de bloques, aunque esta selección de muestra no necesariamente es al azar. 

Debemos pensar en dos características para reconocer un bloque: 

- Cada bloque **debe de contener** todos los tratamientos
- Se puede aumentar su número 

Cuando se tiene una observación por tratamiento dentro del bloque, el número de réplicas es igual al número de bloques, aunque esto no necesariamente debe de ser así. 

- Cuando hay más de una réplica dentro de un bloque tengo problemas de independencia de las observaciones. No se puede hacer un ANOVA y debo de hacerlo con modelos mixtos. 

## Enfoques para el análisis de un diseño de bloques 

### Clásico 

Partición de las sumas de cuadrados total en un análisis de varianza, se añaden los bloques como variabilidad.

- Con este enfoque la varianza residual se puede reducir considerando las diferencias de los promedios entre los bloques, entre más distintos son los bloques mayor variabilidad se elimina.

El modelo de suma nula con un factor y datos tomados por bloque es similar a un diseño con dos factores sin interacción. 

$$
\mu_{jk}=\mu+\tau_j+\delta_k
$$
donde: 

-$\tau_j$ y $\delta_k$ son el efecto del factor y el del bloque respectivamente. 
- j=1,...,a con a tratamientos
- k=1,...,b con b bloques. 

También se tiene que: 

- $\sum^a_{j=1} \tau_j =0$ 
- $\sum^b_{k=1} \delta_k =0$ 


### Moderno 

Usa *modelos mixtos* Ya que el efoque del bloque se considera un elemento aleatorio que tiene una distribución $N(0,\sigma^2_\delta)$

- Cuando la varianza de esta distribución es cercana a 0 se considera que el efecto de los bloques no es importante (porque todos se parecen) 
    - Se tiene esta prueba de hipótesis $H0:\sigma^2_\delta=0$ 
    
- Cuando hay más de una réplica por tratamiento por bloque este modelo es el más adecuado. Ya que **no hay independencia**. El anova asume independencia, este enfoque no. 

Para el modelo se debe de tomar en cuenta que los efectos de bloque vienen de una distribución de *media 0*.

La media 0 es el equivalente a la restricción de suma nula para los efectos del bloque pero para toda la población. 


$$
\mu_{jk}=\mu+\tau_j+\delta_k
$$

donde: 

-$\tau_j$ y $\delta_k$ son el efecto del factor y el del bloque respectivamente. 

- j=1,...,a con a tratamientos

- $\delta \sim N(0,\sigma^2_\delta)$


# Análisis de varianza con bloques. (Enfoque Clásico)


Es lo mismo que hemos hecho en todo el curso, dividir la variabilidad total (Suma de cuadrados total) en diferentes fuentes de variación. 

- Variación *entre* los promedios de un factor.
- Variación *entre* los promedios de los bloques. 
- Variación *dentro* de los tratamientos eliminando el efecto del bloque.


## Variación entre los promedios de un factor. (CMTrat)

$$
CMTrat=\frac{\sum r (\bar y_{j*}-\bar y )^2}{a-1}
$$

Donde:

- $\bar y _{j*}$ Promedio del tratamiento j marginal al bloque. 
- A: número total de tratamientos.
- r: Cantidad de réplicas de ese tratamiento.


## Variación entre los promedios de los bloques. (CMBloque)

$$
CMBloque=\frac{\sum a (\bar y_{*k}-\bar y )^2}{b-1}
$$

Donde:

- $\bar y _{*k}$ Promedio de todas las observaciones dentro del bloque. 
- A: número total de tratamientos.
- B: Cantidad de bloques.



## Variabilidad residual (CMRes)

Ya no es una ponderación directa de las varianzas por tratamiento, ya que primero **debemos eliminar el efecto del bloque en la Suma de Cuadrados**

- En este sentido entonces el CMRes es una mediad de variabilidad dentro de los tratamientos una vez eliminado el bloque. 

$$
SCRes=[\sum(n_i-1)*S_i^2]-SCBloque
$$

Tenemos entonces:

- GL: (n-1)-(a-1+b-1)
- $CMRes: SCRes/gl$
Acá a son los tratamientos y b son los bloques
También pueden ser vistos como n-el número de parámetros del modelo (o cuantos coeficientes hay, hay que tener cuidado porque estos pueden cambiar con suma nula o así)
**NOTA:** Ya con esto podemos hacer la tabla de análisis de varianza en la que debo de observar la *probabilidad asociada al factor*

## Bloques con un diseño factorial. 

Es posible añadir bloques y más de un factor, simplemente tenemos más cosas que tomar en cuenta. 

- Cuando se analizan varios factores en un mismo experimento y se pueden tener observaciones para cada tratamiento dentro de la misma unidad experimental, esta unidad funciona como bloque.
- Se debe de aleatorizar la asignación de las unidades de observación dentro de 
- Tenemos más fuentes de variación. 
- Se asume que no hay interacción entre el factor y el bloque. 
- Si se puede análizar la interacción entre los factores. 
- El tiempo puedo funcionar como un bloque, entonces dentro de cada unidad de tiempo se deben de observar los tratamientos. 

**NOTA:** Es de suma importancia identificar bien los bloques. 

### El modelo de un diseño factorial con bloques. 

$$
\mu_{jkl}=\mu+\tau_j+\phi_k+\delta_l+(\tau \phi)_{jk}
$$
Donde

- $\mu$ es la media general. 
- $\tau_j$ es el efecto del j-ésimo nivel del factor A 
- $\phi_k$ es el efecto del k-ésimo nivel del factor B
- $\delta_l$ es el efecto del l-ésimo bloque. 
- $(\tau \phi)_{jk}$ es el efecto de interacción entre el factor A y B. 

### Ejemplo de las mariposas

Este ejemplo nos ayuda a comprender que hay veces que el concepto de lo que estamos usando como bloque no es tan claro. En este ejemplo se visitan los árboles más de una vez, entonces el bloque sería el árbol en un momento determinado. 

**NOTA:** En caso de que encontremos que el efecto de los bloques es insignificavo, *NO* se pueden eliminar del modelo, pues el experimento ya fue diseñado de esta forma. 

# Eficiencia Relativa

La pregunta lógica es ¿ha tenido éxito la construcción de bloques? 

- En caso de que la respuesta es sí, quiere decir que es un diseño eficiente y que la SCBloques explica una buena parte de la SCTotal. 
    - Esto quiere decir que se reduce la SCRes, aumenta el valor de F y aumentando entonces la probabilidad de rechazar la prueba, lo que quiere decir que se mejora la potencia. 
    
Para saber si el diseño de bloques es eficiente hay que entonces calcular la *eficiencia relativa*. Para esto se compara un diseño de bloques con un diseño simple al azar. 

Para ello debemos tomar en cuenta que: 

- El número de grados de libertad residuales en un diseño al azar es *n-a* mientras que el de un diseño de bloques es *(n-1)-(a-1+b+1)*, es decir los gl son menores en un DB. 

- Como disminuyen los gl, el valor de F disminuye también, implica que es más difícil rechazar H0 y la potencia disminuye. Por esto es crucial no hacer un bloqueo innecesario. 

- Es razonable pensar que si las medias de los bloques son iguales, entonces el bloqueo no fue necesario. 

- Por esto calculamos la Eficiencia Relativa. 

Pero **¿Qué es la eficiencia?**

La eficiencia de un diseño es el inverso de su varianza residual. 

Entonces la eficiencia relativa fr DB respecto a DA está definida por: 

$$
EE(DB a DA)=\frac{E(DB)}{E(DA)}=\frac{1/Var(DB)}{1/Var(DA)}=\frac {Var(DA)}{Var(DB)}
$$

Esto supone que necesitamos la verdadera varianza de ambos diseños, sin embargo las varianzas son desconocidas. Se puede estimar la eficiencia relativa pero tenemos que tomar en cuenta que solo vamos a tener datos del DB. 

La estimación entonces sería la siguiente:

$$
EER(DB a DA)=\frac{(f_B+1)(f_A+3)CMRes(DA)}{(f_B+3)(f_A+1)CMRes(DB)}
$$

Donde: 

- $f_A$ y $f_B$ son los grados residuales de cada diseño. 

Pero no contamos con el diseño de Aleatorio, podemos estimarlo mediante: 

$$
CMRes(DA)= \frac{(b-1)CMBloque+b(a-1)CMRes(DB)}{ba-1}
$$

Donde= 

- b son los bloques.
- a los niveles de un factor.

**NOTA:** Para un diseño de dos factores a*=Niveles del factor A x Niveles del factor B 

## Interpretación.

- Se requieren r=bxER réplicas por tratamiento en un Diseño aleatorio para que sea tan efectivo como un diseño de bloques. 

- La ER solo habla de la precisión de las estimaciones y no de la potencia. Por esta razón se recomienda usar un DB mejpr que un DA cuando ER>1.25



# Bloques Incompletos. 

Hay que recordar que el diseño de bloques requiere inicialmente que haya al menos una observación por tratamiento en cada bloque. 

Sin embargo, hay situaciones en las que no es posible por razones prácticas (O por la razón que sea).

Por ejemplo: 

Si se tienen 7 tratamientos y el bloque es una unidad de tiempo (el día por ejemplo) pero en cada día solo puedo aplicar 7 tratamientos ¿Qué hago?

Asigno solo 6 tratamientos por día pero debo de hacerlo de forma aleatoria. 

Entonces el número de bloques debe de ser tal que se logre un balance, por lo que se recomienda que sea **un múltiplo del número de tratamientos**

Si tengo 7 tratamientos, debo de tener 7,14,21... bloques. Los inicios aleatorios deben de ser la cantidad de tratamientos máximos que tengo por día, multiplicada por el número que multiplica a la cantidad de tratamientos para obtener la cantidad de bloques. 6,12,18, etc. De forma que siempre haya una concordancia. 

## Totales ajustados 

$$
Q_j=y_{j.}-\frac{1}{p}\sum^b_{k=1}n_{jk}y_{.k}
$$

Donde:

- $y_{j.}$ es la suma del j-ésimo tratamiento.
- $y_{.k}$ es la suma del késimo bloque.


$$
SCTrat.aj=\frac{p\sum^a_{j=1}Q_j^2}{\lambda a}
$$

Donde:

- a es el número total de tratamientos. 
- p es el número de tratamientos en cada bloque
- $\lambda=r(p-1)/(a-1)$ 
- r es el número de bloques en los que aparece un tratamiento. 

Y la SCResB= SCTot-SCTrat.aj-SCBloque. 

En R

yjp=tapply(basey,base$conc,sum)
ypk=tapply(basey,base$bloque,sum)
p=3
njk=table(basey,base$bloque)

yjp-as.vector(njk%*%ypk/p)


Para hacerlo automáticamente debe de hacerse 

lm(y~bloque+factor,data = base)

A la hora de hacer un diseño de bloques incompletos cuando la cantidad de bloques es mayor a la cantidad de tratamientos hay que tener cuidado y tenemos dos opciones para hacerlo correctamente. 

Podemos hacer una "simetría de inicios" donde los inicios coincidan en los primeros a bloques con los segundos a bloques. 

```{r echo=FALSE}
knitr::include_graphics("C:/Users/danie/OneDrive/Cosas/Escritorio/Carrera/Experimentos/Fotos resumenes/9.png")
```

O cuando los inicios son completamente aleatorios podemos hacerlos por aparte primero los primeros a bloques, ignorando los demás, después los segundos x bloques, ignorando los demás. 

```{r echo=FALSE}
knitr::include_graphics("C:/Users/danie/OneDrive/Cosas/Escritorio/Carrera/Experimentos/Fotos resumenes/10.png")
```

En excel podemos verificar que cada bloque efectivamente tiene la cantidad de tratamientos determinada con la función *CONTARA*



# Parcelas divididas 

Es un tipo especial del diseño de bloques. En el cual se tienen 2 factores o más. Pero el bloque **solo considera los niveles de uno de los factores**, mientras que el los bloques se clasifican en los niveles del segundo factor. 

Entonces tengo lo siguiente: 

- El factor que clasifica a los bloques es el factor superior o el factor de parecela. 

- El factor cuyos niveles están dentro del bloque es el factor de subparcela. 

- Este tipo de diseño se analiza únicamente mediante el enfoque de modelos mixtos. 

Tenemos entonces el siguiente modelo: 

$$
\mu_{ijk}=\mu+\alpha_i+\beta_j+(\alpha\beta)_{ij}+\delta_k
$$

Donde: 

- $\alpha_i$ es el efecto del primer factor
- $\beta_j$ es el efecto del segundo factor
- $\delta_k$ es el efecto de la parcela
- $(\alpha \beta)_{ij}$ es el efecto de lainteracción entre los factores. 

Y asumimos que: $\delta \sim N(0, \sigma^2_{\delta}) $


Para el análisis de diseños de parcelas es bueno recordar que tenemos dos niveles, el nivel superior, con su propia unidad experimental y propio o propios factores. Y un nivel inferior con su propia unidad y propio o propios factores. Es difícil generalizar algo así, pero es bueno recordarlo siempre. 

Para usar la función lmer() y calcular las probabilidades hay que conocer los grados de libertad

Los grados de libertad para el error de parcela se obtienen sabiendo que los lotes están anidados dentro de cada método(el factor de parcela). Entonces se tienen a(r-1) grados de libertad, donde a es el número de métodos y r el número de bloques por cada nivel del factor.

El error de subparcela se calcula con n-p-gl.parcela, donde p es el número de coeficientes.

Cuando no hay interacción los grados de libertad de interacción se se suman al error de subparcela. 

Los grados de libertad de parcela no cambian. 

Para los grados de libertad residuales, se puede hacer un modelo como el mixto que se está usando pero normal, sin bloques, se toman los glres y se restan los de gl del error de parcela. 

**¿Qué pasa si quueremos converir eL diseño de bloques a uno de parcelas?** Es posible hacerlo siempre y cuando se le añada un factor que defina o caraterice al bloque. 

Un ejemplo de un diseño de parcelas: 

```{r echo=FALSE}
knitr::include_graphics("C:/Users/danie/OneDrive/Cosas/Escritorio/Carrera/Experimentos/Fotos resumenes/8.png")
```


# En R 

## Centrar los datos. 

modc=lm(y~bloque,data = base)
fit=modc$fit

rc=y-fit+mean(y)

a la hora de comparar el gráfico centrado con el no centrado es importante observar la escala de los datos, sin embargo **la forma correcta siempre va a ser con los datos centrados**

## Gráfico 

library(ggplot2)

ggplot(base1,aes(x=bloque,y=y,group = trat))+
  stat_summary(fun = "mean",geom = "line",aes(linetype = trat))

Con Lattice

library(lattice)
xyplot(y ~ fact1, groups = fact2,type="a",auto.key=list(columns=4),
xlab="fact1",ylab="y",data=base)

Estos gráficos se pone en el eje x el factor que no es de diseño, en el y la variable respuesta y las líneas son entonces el factor de diseño

## Modelos Mixtos 

lme(y~x, random = ~1|bloque,data = base1)

lmer(y~y+(1|bloque),data = base1), para este nos da un valor de t y hay que correr la hipótesis de dos colas. 

pt(t,glresiduales,lower.tail = F)*2

Para obtener el LRT con lmer: drop1(mod,test="chisq")



## Homocedasticidad 

En este caso, se recomienda obtener los residuales del modelo con bloques y luego hacer la prueba sobre estos residuales con el factor de la siguiente forma: bartlett.test(mod$res~trat)


## Probabilidades 

lsmeans(mod2, pairwise~"factor", adjust="tukey")


## Gráfico de lineas 










